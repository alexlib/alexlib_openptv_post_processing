""" Python script and functions that convert the ptv_is.* database 
generated by OpenPTV (for the crowd tracking experiment) into the Python data
structures of Particles, Frames, List of Frames, Trajectories and plots the data
"""
import os
import glob
import numpy as np
import matplotlib.pyplot as plt


class Particle(object):
    """ Particle object that defines every single tracked point
    the attributes are position (x,y,z) and velocities (u,v,w), time instance (t)
    and trajectory identity (id)
    """
    def __init__(self,p=0,n=0, x=0,y=0,z=0,t=0,id=None,\
    u=0,v=0,w=0):
        self.p = p
        self.n = n
        self.x = x
        self.y = y
        self.z = z
        self.t = t
        self.id = id
        self.u = u
        self.v = v
        self.w = w
        
    def __str__(self):
        return '%.2f %.2f %.2f %.2f %.2f %.2f %d %d' % (self.x,self.y,self.z,\
        self.u,self.v,self.w,self.t,self.id)
        
    def __repr__(self):
        return str(self)
        
        
class Frame(list):
    """ Frame class is a list of Particles in the given frame, sharing the same
    time instance (t)
    """
    def __new__(cls, data=None,len=0):
        obj = super(Frame, cls).__new__(cls, data)
        return obj

    def __str__(self):
        s = 'Frame(['
        for i in self:
            s += str(i)
        s += '])'
        return s
        # return 'Traj(%s)' % list(self)
        
    def __repr__(self):
        return str(self)

    def __add__(self, other):
        return Frame(list(self) + list(other))
        
    def len(self):
        return len(list(self))
        

class Trajectory(list):
    """ Trajectory class is a list of Particles that are linked together in 
    time
    """
    def __new__(cls, data=None):
        obj = super(Trajectory, cls).__new__(cls, data)
        return obj

    def __str__(self):
        s = 'Traj(['
        for i in self:
            s += str(i)
        s += '])'
        return s
        # return 'Traj(%s)' % list(self)
        
    def __repr__(self):
        return str(self)

    def __add__(self, other):
        return Trajectory(list(self) + list(other))

        
def frame_from_file(filename):
    """ frame_from_file(filename) reads the data
    in the given file into a frame as a list
    of the particles
    """
    t = int(filename.split('.')[-1])
    with open(filename) as f:
        np = int(f.readline())
        frame = Frame()
        for i in range(np):
            p = Particle()
            vals = f.readline().split()
            p.p = int(vals[0])
            p.n = int(vals[1])
            p.x = float(vals[2])
            p.y = float(vals[3])
            p.z = float(vals[4])
            p.t = t
            frame.append(p)
    return frame
                        
def read_ptv_data_from_directory(directory,first=None,last=None):
	""" 
        directory = '/Users/alex/Desktop/crowd_tracking/res/'
        data = read_ptv_data_from_directory(directory,38940,38970)
	"""
	d = glob.glob(os.path.join(directory,'ptv_is.*'))
	d.sort()
	dlist = [int(os.path.splitext(name)[1][1:]) for name in d]
	if first is None or first < dlist[0]:
		first = 0
	else:
		first = dlist.index(first)
#
	if last is None or last > dlist[-1]:
		last = -1
	else:
		last = dlist.index(last)
	
	
	d = d[first:last] # only files between first and last
	dlist = dlist[first:last]
	data = []
	
	for ind,filename in enumerate(d):
		data.append(frame_from_file(filename))
	
	return data
    
    
def link_trajectories(data):
    """ performs linking of the particles in the frame according to their
    attributes provided by the OpenPTV: previous and next (or left and right)
    Particles are assigned a unique identity during this operation
    """
    id = 0
    # first frame, assign the id to the first frame
    # particles in ascending order, starting from 0
    for particle in data[0]:
        if particle.n != -2:
            particle.id = id
            id += 1
    for ind,frame in enumerate(data[1:]):
        # print ind
        past = data[ind]
        for particle in frame:
            # print 'prev = ', particle.p
            if particle.p == -1: # no past
                if particle.n == -2: # no future
                    pass
                    # frame.remove(particle)
                else:
                    particle.id = id #  new id
                    id += 1 # update lastid
            else:
                # print 'prev =',particle.p
                # print 'id = ',past[int(particle.p)].id
                particle.id = past[int(particle.p)].id
    return id #lastid

def clean_data(data):
    """ clean_data(data) removes the unlinked
    particles and empty frames
    """
    for frame in data:
        for particle in frame:
            if particle.id == None:
                frame.remove(particle)
        
    for frame in data[-1:0:-1]: # reverse reading
         if len(frame) == 0:
            data.remove(frame)
            
    return data
            
 
def frames_to_traj(data,lastid=None):
    """ converts data from frames of particles into 
    trajectories of particles, using unique identities
    """
    if lastid == None:
        lastid = data[-1][-1].id
        
    print lastid 
        
    # prepare the dataset
    traj = [Trajectory() for i in range(lastid+1)]
    
    for frame in data:
        for particle in frame:
            traj[particle.id].append(particle)
                
    for t in traj:
        if len(t) < 3:
            traj.remove(t)
            
    return traj 
            
 
        
def calculate_velocity(traj):
    """ estimates velocity of the particles along the trajectory using simple
    forward and backward difference scheme
    TODO: to be improved using smooth splines and higher order differentation 
    schemes
    """
    for t in traj: # for each trajectory
        # last particle use backward difference
        t[-1].u = t[-1].x - t[-2].x
        t[-1].v = t[-1].y - t[-2].y
        t[-1].w = t[-1].z - t[-2].z
        for i,p in enumerate(t[:-1]): # for other particles
            p.u = t[i+1].x - p.x
            p.v = t[i+1].y - p.y
            p.w = t[i+1].z - p.z
    
    return traj
    

def plot_traj(traj,fig=None):
    """ plots single trajectory as dots, curves and arrows
    using matplotlib
    """
    if fig == None:
        plt.figure()
        
    x,y,z,u,v,w = [],[],[],[],[],[]
    for p in traj: # for all particles
        x.append(p.x)
        y.append(p.y)
        z.append(p.z)
        u.append(p.u)
        v.append(p.v)
        w.append(p.w)
        
    plt.plot(x,y,'o--')
    plt.quiver(x,y,u,v)
        
 
def plot_all_trajectories(list_of_traj):
    """ plots all the trajectories in a given list of trajectories on a single
    figure, overlapping the curves
    """
    fig = plt.figure()
    plt.hold(True)
    for traj in list_of_traj:
           plot_traj(traj,fig)
    fig.show()

 
if __name__ == '__main__':
     directory = '/Users/alex/Desktop/crowd_tracking/res/'
     # data = read_ptv_data_from_directory(directory,38940,38999)
     data = read_ptv_data_from_directory(directory,38940,49100)
     link_trajectories(data)
     clean_data(data)
     clean_data(data) # check why it's recursive?
     list_of_traj = frames_to_traj(data)
     calculate_velocity(list_of_traj)
     plot_all_trajectories(list_of_traj)
     np.savez(os.path.join('/Users/alex/Desktop/crowd_tracking','ptv_is'),data,list_of_traj)
     
                         
                             

#------------------------------
#def _build_trajectories(data):
#	"""
#	build_trajectories(data) is responsible for the book keeping of the trajectories, 
#	using the prev,next fields in the frames,creating new set of data, in the form of trajectories
#	"""
#	# first frame, initialization
#	trajid = 0 # running trajid counter
#	ind, = (data[0].next != -2).nonzero()
#	if len(ind) > 0:
#		data[0].trajid[ind] = range(trajid,trajid+len(ind))
#		trajid += len(ind)
#		print "data[0].trajid", data[0].trajid
#	for i,frame in enumerate(data[1:]): # from second frame and on: keep tracking the id
#		old, = (frame.prev > -1).nonzero() # those that continue from the previous frame
#		frame.trajid[old] = data[i].trajid[frame.prev[old]-1] # notice i runs from zero
#		print "frame.trajid", frame.trajid
#		# new trajectories - no previous, but there is next
#		ind, = np.logical_and(frame.prev == -1, frame.next != -2).nonzero()
#		if len(ind) > 0:
#			frame.trajid[ind] = range(trajid,trajid+len(ind))
#			trajid += len(ind)
#			print "frame.trajid next", frame.trajid
#		frame.t = frame.t*np.ones_like(frame.x)
#		
#	return(data)
#----------------------------
#def _ptv_to_traj(data,minlength=5):
#	""" 
#	ptv_to_traj(data) converts the data in frames with already prepared trajid to the data in form of
#	trajectories
#	"""
#	
#	trajid = np.hstack([f.trajid for f in data])
#	x = np.hstack([f.x for f in data])
#	y = np.hstack([f.y for f in data])
#	z = np.hstack([f.z for f in data])
#	t = np.hstack([f.t for f in data])
#
#	traj = []
#	ind, = ((x != 0) & ( y != 0) & (z != 0)).nonzero()
#
#	x = x[ind]
#	y = y[ind]
#	z = z[ind]
#	t = t[ind]
#	trajid = trajid[ind]
#	dt = np.diff(np.unique(t)).min()
#	unique_trajid = np.unique(trajid)
#	print unique_trajid
#
#	counter = -1
#	trajlen = []
#	for tr in unique_trajid:
#		id = trajid == tr
#		if sum(id) > minlength:
#			counter += 1
#			# import pdb; pdb.set_trace()
#			trajlen.append(sum(id))
#			u = np.gradient(x[id])
#			v = np.gradient(y[id])
#			w = np.gradient(z[id])
#			ax = np.gradient(u)
#			ay = np.gradient(v)
#			az = np.gradient(w)
#			tmp = np.rec.fromarrays([x[id],y[id],z[id],u,v,w,ax,ay,az,t[id]],names='x,y,z,u,v,w,ax,ay,az,t')
#			tmp.trajid = tr
#			traj.append(tmp)
#
#	return traj

## -------------------------
#if __name__ == '__main__':
#	print(' Reading ... \n')
#	# directory = '/Volumes/alex/openptv_experiment/res';
#	directory = '/Users/alex/Desktop/crowd_tracking/res/'
#	data = _read_ptv_is_files(directory,38940,38999) #('/Users/alex/Desktop/GUI/pyptv2/test_for_v1_02/res/')
#	np.save('data',data)
#	print(' Building trajectories ... \n')
#	data = _build_trajectories(data)
#	np.save('data',data)
#	print('Restructuring and deriving velocity ... \n')
#	traj = _ptv_to_traj(data)
#	print(' Saving ... \n')
#	np.save('traj',traj)
# 	
# 	% If manual cleaning is needed
# 	traj = graphical_cleaning_traj(traj,'xy')
# 	
# 	plot_long_trajectories(traj,10)
# 	
# 	% save(fullfile(directory,'traj.mat'),'traj')
# 	% load(fullfile(directory,'traj.mat'),'traj')
# 	
# 	s = 100;
# 	for i = 1:length(traj)
# 		newtraj(i) = link_trajectories_smoothn(traj(i),s);
# 	end
# 	
# 	% for i = 1:length(traj)
# 	%     newtraj(i) = link_trajectories_rbf(traj(i),0.1);
# 	% end
# 	[traj,removelist] = haitao_linking_criteria(newtraj,10,1.5);
# 	% save colloid_traj traj
# 	
# 	
# 	plot_long_trajectories(traj,5)
# 	hold on
# 	plot_long_trajectories(newtraj(removelist),1,1)